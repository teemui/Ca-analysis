
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>ca_response</title><meta name="generator" content="MATLAB 9.3"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2018-10-18"><meta name="DC.source" content="ca_response.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#1">ca_response</a></li><li><a href="#3">methods</a></li><li><a href="#5">ca_analysis</a></li><li><a href="#6">Bleach correction</a></li><li><a href="#7">Calculate curve parameters</a></li><li><a href="#8">Plot the calculated parameters</a></li></ul></div><h2 id="1">ca_response</h2><p>Creates a ca_response object for each time-intensity data pair (e.g. individual cell) with properties listed below. The methods contain the ca_analysis function, which calculates the data variables for each ca_response object.</p><pre class="codeinput"><span class="keyword">classdef</span> ca_response
</pre><pre class="codeinput">    properties

        timeVector <span class="comment">%time data for each intensity response</span>
        rawData <span class="comment">%raw intensity data without any processing</span>
        correctedData <span class="comment">%data with bleach correction applied</span>
        relativeData <span class="comment">%normalized intensity data</span>
        filteredData <span class="comment">%relative data with filtering applied</span>
        interpolatedData <span class="comment">%slot for possible interpolated data (not used now)</span>
        ATPtype <span class="comment">%ATP stimulus type (e.g. first or second ATP stimulus)</span>
        surface <span class="comment">%cell culture surface</span>
        timepoint <span class="comment">%timepoint for Ca-imaging</span>
        cellLine <span class="comment">%cell line used</span>
        ROI <span class="comment">%ROI number</span>
        maxAmplitude <span class="comment">%max relative amplitude</span>
        rise50 <span class="comment">%rise time to halfway intensity</span>
        time2max <span class="comment">%rise time to max intensity</span>
        decay50 <span class="comment">%decay time from max to halfway</span>
        duration50 <span class="comment">%duration between 50% intensity points</span>
        startFit <span class="comment">%index for the start of fitting for bleach correction</span>
        startId <span class="comment">%index for the start of response</span>
        idx50_1 <span class="comment">%index for first halfway point (rise50)</span>
        idx50_2 <span class="comment">%index for second halfway point (decay50)</span>
        maxId <span class="comment">%index for maximum intensity</span>
        isDiscarded <span class="comment">%logical index for possible discarding</span>
        isSkipped <span class="comment">%logical index for possible skipping</span>

    <span class="keyword">end</span>
</pre><h2 id="3">methods</h2><pre class="codeinput">    methods
</pre><h2 id="5">ca_analysis</h2><p>The function performs bleach correction, calculates the amplitude and time variables from each intensity curve and adds them as properties to the ca_response object. The function is called from the readCaData function in readData.m.</p><pre class="codeinput">        <span class="keyword">function</span> obj = ca_analysis(obj,ROI,cell)
</pre><h2 id="6">Bleach correction</h2><pre class="codeinput">            <span class="comment">% Exctract raw data from the ca_response object.</span>
            time = obj.timeVector;
            A = obj.rawData;
            ansId = 0;

            <span class="comment">% Pick the interval used in searching for the minimum before the response.</span>
            <span class="keyword">if</span> ~isempty(obj.startId) == 1

                <span class="comment">%In case the object already has fit data</span>
                bounds = [obj.startFit, obj.startId];

            <span class="keyword">else</span>

                <span class="comment">%Adjust if needed</span>
                bounds = [1, 400];

            <span class="keyword">end</span>

            counter = 1;

            <span class="keyword">while</span> ansId == 0

                B = A(bounds(1):bounds(2));

                <span class="keyword">if</span> counter &gt; 1 || ~isempty(obj.startId) == 1

                    <span class="comment">%In case the object already has a start index</span>
                    obj.startId = bounds(2);

                <span class="keyword">else</span>

                    <span class="comment">%Finds the minimum value between fit start and end points</span>
                    [~, obj.startId] = min(B);

                    <span class="keyword">if</span> obj.startId &lt; 100

                        <span class="comment">%If the index is too close to start of the data,</span>
                        <span class="comment">%adds a certain amount of data points</span>
                        obj.startId = obj.startId + 200;

                    <span class="keyword">end</span>

                    obj.startId = round((obj.startId + (bounds(1)-1)));

                <span class="keyword">end</span>

                <span class="comment">% Fit an exp model to the baseline and calculate corrected data.</span>
                data2fit = A((bounds(1):obj.startId));
                fittedData = fit(time(bounds(1):obj.startId), data2fit, <span class="string">'exp1'</span>);
                model = fittedData.a.*exp(fittedData.b.*time);
                baseline = mean(A(1:10)); <span class="comment">% Start value for the corrected baseline.</span>
                basevec = baseline*ones(length(time));
                difference = baseline - model;
                correctedA = A + difference;

                <span class="comment">% Plot the original and corrected data</span>
                figure(<span class="string">'units'</span>,<span class="string">'normalized'</span>,<span class="string">'outerposition'</span>,[0 0 1 1]);
                subplot(1,2,1)
                hold <span class="string">on</span>
                plot(time, A, <span class="string">'b'</span>)
                plot(time(bounds(1):obj.startId), data2fit, <span class="string">'r'</span>)
                plot(time, model, <span class="string">'k--'</span>)
                plot(time, correctedA, <span class="string">'g'</span>)
                plot(time, basevec, <span class="string">'k-.'</span>)
                hold <span class="string">off</span>

                title(<span class="string">'Corrected data'</span>, <span class="string">'Interpreter'</span>, <span class="string">'none'</span>)
                legend(<span class="string">'original data'</span>, <span class="string">'data used in fitting'</span>, <span class="string">'fitted model'</span>,<span class="keyword">...</span>
                    <span class="string">'corrected data'</span>, <span class="string">'baseline'</span>)
                xlabel(<span class="string">'Time (s)'</span>)
                ylabel(<span class="string">'Intensity'</span>)

                correctAnswer = 0;

                <span class="comment">% Ask for user input and correction for the fit boundaries</span>
                <span class="keyword">while</span> correctAnswer == 0
                    prompt = <span class="string">'Accept correction (y),skip correction (s),\nselect new boundaries (n) or discard response (d): '</span>;
                    answer = input(prompt, <span class="string">'s'</span>);

                    <span class="keyword">if</span> strcmp(answer, <span class="string">'y'</span>)

                        obj.correctedData = correctedA;
                        obj.startFit = bounds(1);
                        bounds(2) = obj.startId; <span class="comment">% The fit end point is taken</span>
                        <span class="comment">% as the response start point (can be changed later by the user)</span>
                        ansId = 1;
                        correctAnswer = 1;

                    <span class="keyword">elseif</span> strcmp(answer, <span class="string">'n'</span>)

                        <span class="comment">% In case of 'n', give user the possibility to</span>
                        <span class="comment">% select new boundaries graphically with the mouse</span>
                        disp(<span class="string">'Select the boundaries for fitting with the mouse cursor.'</span>)
                        [bounds, ~] = ginput(2);
                        bounds = round(2*bounds); <span class="comment">%Convert time data to index</span>
                        counter = counter + 1;
                        correctAnswer = 1;
                        close

                    <span class="keyword">elseif</span> strcmp(answer, <span class="string">'s'</span>)

                        <span class="comment">% Possibility to skip bleach correction, e.g. if</span>
                        <span class="comment">% the baseline is too fluctuating for fitting.</span>
                        obj.correctedData = obj.rawData;
                        bounds(2) = obj.startId;
                        data2fit = A(bounds(1):bounds(2));
                        obj.isSkipped = 1;
                        correctAnswer = 1;
                        ansId = 1;

                    <span class="keyword">elseif</span> strcmp(answer, <span class="string">'d'</span>)

                        <span class="comment">% Possibility to discard the response if the data</span>
                        <span class="comment">% is not analyzable.</span>
                        obj.correctedData = correctedA;
                        obj.isDiscarded = 1;
                        <span class="keyword">return</span>

                    <span class="keyword">else</span>

                        disp(<span class="string">'Please enter y (yes), n (no), s (skip) or d (discard).'</span>);

                    <span class="keyword">end</span>

                <span class="keyword">end</span>

            <span class="keyword">end</span>
</pre><h2 id="7">Calculate curve parameters</h2><pre class="codeinput">            <span class="comment">% Calculate relative intensity and filter out noise</span>
            obj.relativeData = obj.correctedData/mean(obj.correctedData(1:10));
            obj.filteredData = smooth(obj.relativeData, <span class="string">'moving'</span>);

            <span class="comment">% Find the points that are used in the calculations in case</span>
            <span class="comment">% the object parameters are empty.</span>
            <span class="keyword">if</span> isempty(obj.maxId) == 1

                [~, obj.maxId] = max(obj.filteredData);
                halfway = (obj.filteredData(obj.maxId)+obj.filteredData(obj.startId))/2;
                <span class="comment">% Find the points where the curve crosses the halfway value</span>
                <span class="comment">% (see findcrossings.m)</span>
                crossings1 = findcrossings(obj.filteredData(obj.startId:obj.maxId),halfway);
                crossings2 = findcrossings(obj.filteredData(obj.maxId:end),halfway);
                <span class="comment">% The first crossings are taken as the halfway points. Can</span>
                <span class="comment">% be changed e.g. to last crossings etc.</span>
                obj.idx50_1 = crossings1(1) + obj.startId;
                obj.idx50_2 = crossings2(1) + obj.maxId;

                <span class="comment">% Calculate the amplitude and time parameters</span>
                obj.maxAmplitude = obj.filteredData(obj.maxId) - obj.filteredData(obj.startId) + 1;
                obj.time2max = time(obj.maxId) - time(obj.startId);
                obj.rise50 = time(obj.idx50_1) - time(obj.startId);
                obj.decay50 = time(obj.idx50_2) - time(obj.maxId);
                obj.duration50 = time(obj.idx50_2) - time(obj.idx50_1);

            <span class="keyword">end</span>
</pre><h2 id="8">Plot the calculated parameters</h2><pre class="codeinput">            baseline2 = mean(obj.filteredData(1:10));
            basevec2 = baseline2*ones(length(time),1);
            halfway = (obj.filteredData(obj.maxId)+obj.filteredData(obj.startId))/2;
            halfvec = halfway*ones(length(time));

            subplot(1,2,2)
            hold <span class="string">on</span>
            plot(time, obj.filteredData, <span class="string">'HandleVisibility'</span>, <span class="string">'off'</span>)
            plot(time, basevec2, <span class="string">'HandleVisibility'</span>, <span class="string">'off'</span>)
            plot(time, halfvec, <span class="string">'HandleVisibility'</span>, <span class="string">'off'</span>)
            plot(time(obj.startId), obj.filteredData(obj.startId), <span class="string">'rx'</span>, <span class="string">'LineWidth'</span>, 2)
            plot(time(obj.maxId), obj.filteredData(obj.maxId), <span class="string">'kx'</span>, <span class="string">'LineWidth'</span>, 2)
            plot(time(obj.idx50_1), obj.filteredData(obj.idx50_1), <span class="string">'gx'</span>, <span class="string">'LineWidth'</span>, 2)


            <span class="comment">% In case the intensity doesn't fall back under 50%, the second halfway point</span>
            <span class="comment">% is plotted in yellow (adjust the tolerance as needed) and decay50 and duration50</span>
            <span class="comment">% are marked as NaN, as they can't be calculated. This can happen also</span>
            <span class="comment">% when the 50% points are too far apart in intensity, due to rapid changes in</span>
            <span class="comment">% intensity and too small sampling interval.</span>
            <span class="keyword">if</span> abs(obj.filteredData(obj.idx50_1) - obj.filteredData(obj.idx50_2)) &gt; 0.03

                obj.decay50 = NaN;
                obj.duration50 = NaN;
                plot(time(obj.idx50_2), obj.filteredData(obj.idx50_2), <span class="string">'yx'</span>, <span class="string">'LineWidth'</span>, 2)

            <span class="keyword">else</span>

                plot(time(obj.idx50_2), obj.filteredData(obj.idx50_2), <span class="string">'cx'</span>, <span class="string">'LineWidth'</span>, 2)

            <span class="keyword">end</span>

            title(<span class="string">'Analyzed data'</span>, <span class="string">'Interpreter'</span>, <span class="string">'none'</span>)
            legend(<span class="string">'Response start point'</span>, <span class="string">'Curve maximum'</span>, <span class="string">'Halfway (rise)'</span>, <span class="string">'Halfway (decay)'</span>)
            xlabel(<span class="string">'time (s)'</span>)
            ylabel(<span class="string">'Relative intensity'</span>)

            hold <span class="string">off</span>

            suptitle([obj.cellLine, <span class="string">' '</span>, obj.surface, <span class="string">' '</span>, obj.timepoint,<span class="string">' ROI '</span>, num2str(ROI), <span class="string">' cell '</span>, num2str(cell)])

            correctAnswer2 = 0;

            <span class="keyword">while</span> correctAnswer2 == 0

                <span class="comment">% Ask user input whether the calculated points are correct.</span>
                prompt = <span class="string">'Accept calculated points (y/n): '</span>;
                answer = input(prompt, <span class="string">'s'</span>);

                <span class="keyword">if</span> strcmp(answer, <span class="string">'y'</span>)

                    obj.correctedData = correctedA;
                    correctAnswer2 = 1;

                <span class="keyword">elseif</span> strcmp(answer, <span class="string">'n'</span>)

                    <span class="comment">% In case corrections are needed. Points are selected</span>
                    <span class="comment">% in order (start, 50% rise, maximum, 50% decay) with</span>
                    <span class="comment">% mouse (left click -&gt; new value, right click (or any</span>
                    <span class="comment">% other input) -&gt; keep old value)</span>
                    disp(<span class="string">'Select the points with the mouse cursor in the following order: start, halfway (rise), maximum, halfway(decay)'</span>)
                    [points, ~, button] = ginput(4);

                    <span class="keyword">if</span> button(1) == 1
                        obj.startId = round(2*points(1));
                    <span class="keyword">end</span>

                    <span class="keyword">if</span> button(2) == 1
                        obj.idx50_1 = round(2*points(2));
                    <span class="keyword">end</span>

                    <span class="keyword">if</span> button(3) == 1
                        obj.maxId = round(2*points(3));
                    <span class="keyword">end</span>

                    <span class="keyword">if</span> button(4) == 1
                        obj.idx50_2 = round(2*points(4));
                    <span class="keyword">end</span>

                    <span class="comment">% Calculate new points with the user input</span>
                    obj.maxAmplitude = obj.filteredData(obj.maxId) - obj.filteredData(obj.startId) + 1;
                    obj.time2max = time(obj.maxId) - time(obj.startId);
                    obj.rise50 = time(obj.idx50_1) - time(obj.startId);
                    obj.decay50 = time(obj.idx50_2) - time(obj.maxId);
                    obj.duration50 = time(obj.idx50_2) - time(obj.idx50_1);

                    halfway = (obj.filteredData(obj.maxId)+obj.filteredData(obj.startId))/2;
                    halfvec = halfway*ones(length(time));

                    <span class="comment">% Close the old figure and draw a new one</span>
                    close

                    figure(<span class="string">'units'</span>,<span class="string">'normalized'</span>,<span class="string">'outerposition'</span>,[0 0 1 1]);
                    subplot(1,2,1)
                    hold <span class="string">on</span>
                    plot(time, A, <span class="string">'b'</span>)
                    plot(time(bounds(1):bounds(2)), data2fit, <span class="string">'r'</span>)
                    plot(time, model, <span class="string">'k--'</span>)
                    plot(time, correctedA, <span class="string">'g'</span>)
                    plot(time, basevec, <span class="string">'k-.'</span>)


                    title(<span class="string">'Corrected data'</span>, <span class="string">'Interpreter'</span>, <span class="string">'none'</span>)
                    legend(<span class="string">'original data'</span>, <span class="string">'data used in fitting'</span>, <span class="string">'fitted model'</span>, <span class="string">'corrected data'</span>, <span class="string">'baseline'</span>)
                    xlabel(<span class="string">'Time (s)'</span>)
                    ylabel(<span class="string">'Intensity'</span>)
                    hold <span class="string">off</span>

                    subplot(1,2,2)
                    hold <span class="string">on</span>
                    plot(time, obj.filteredData, <span class="string">'HandleVisibility'</span>, <span class="string">'off'</span>)
                    plot(time, basevec2, <span class="string">'HandleVisibility'</span>, <span class="string">'off'</span>)
                    plot(time, halfvec, <span class="string">'HandleVisibility'</span>, <span class="string">'off'</span>)
                    plot(time(obj.startId), obj.filteredData(obj.startId), <span class="string">'xr'</span>, <span class="string">'LineWidth'</span>, 2)
                    plot(time(obj.maxId), obj.filteredData(obj.maxId), <span class="string">'xk'</span>, <span class="string">'LineWidth'</span>, 2)
                    plot(time(obj.idx50_1), obj.filteredData(obj.idx50_1), <span class="string">'xg'</span>, <span class="string">'LineWidth'</span>, 2)

                    <span class="comment">% In case the intensity doesn't fall back under 50%, the second halfway point</span>
                    <span class="comment">% is plotted in yellow (adjust the tolerance as needed) and decay50 and duration50</span>
                    <span class="comment">% are marked as NaN, as they can't be calculated. This can happen also</span>
                    <span class="comment">% when the 50% points are too far apart in intensity, due to rapid changes in</span>
                    <span class="comment">% intensity and too small sampling interval.</span>
                    <span class="keyword">if</span> abs(obj.filteredData(obj.idx50_1) - obj.filteredData(obj.idx50_2)) &gt; 0.03

                        obj.decay50 = NaN;
                        obj.duration50 = NaN;
                        plot(time(obj.idx50_2), obj.filteredData(obj.idx50_2), <span class="string">'xy'</span>, <span class="string">'LineWidth'</span>, 2)

                    <span class="keyword">else</span>

                        plot(time(obj.idx50_2), obj.filteredData(obj.idx50_2), <span class="string">'xc'</span>, <span class="string">'LineWidth'</span>, 2)

                    <span class="keyword">end</span>

                    title(<span class="string">'Analyzed data'</span>, <span class="string">'Interpreter'</span>, <span class="string">'none'</span>)
                    legend(<span class="string">'Response start point'</span>, <span class="string">'Curve maximum'</span>, <span class="string">'Halfway (rise)'</span>, <span class="string">'Halfway (decay)'</span>)
                    xlabel(<span class="string">'Time (s)'</span>)
                    ylabel(<span class="string">'Relative intensity'</span>)

                    hold <span class="string">off</span>

                    suptitle([obj.cellLine, <span class="string">' '</span>, obj.surface, <span class="string">' '</span>, obj.timepoint,<span class="string">' ROI '</span>, num2str(ROI), <span class="string">' cell '</span>, num2str(cell)])

                <span class="keyword">else</span>

                    disp(<span class="string">'Please enter y or n.'</span>);

                <span class="keyword">end</span>

            <span class="keyword">end</span>

            close
</pre><pre class="codeinput">        <span class="keyword">end</span>
</pre><pre class="codeinput">    <span class="keyword">end</span>
</pre><pre class="codeinput"><span class="keyword">end</span>
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2017b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% ca_response
% Creates a ca_response object for each time-intensity data pair 
% (e.g. individual cell) with properties listed below. The methods
% contain the ca_analysis function, which calculates the data variables
% for each ca_response object.

classdef ca_response

    properties
        
        timeVector %time data for each intensity response
        rawData %raw intensity data without any processing
        correctedData %data with bleach correction applied
        relativeData %normalized intensity data
        filteredData %relative data with filtering applied
        interpolatedData %slot for possible interpolated data (not used now)
        ATPtype %ATP stimulus type (e.g. first or second ATP stimulus)
        surface %cell culture surface
        timepoint %timepoint for Ca-imaging
        cellLine %cell line used
        ROI %ROI number
        maxAmplitude %max relative amplitude
        rise50 %rise time to halfway intensity
        time2max %rise time to max intensity
        decay50 %decay time from max to halfway
        duration50 %duration between 50% intensity points
        startFit %index for the start of fitting for bleach correction
        startId %index for the start of response
        idx50_1 %index for first halfway point (rise50)
        idx50_2 %index for second halfway point (decay50)
        maxId %index for maximum intensity
        isDiscarded %logical index for possible discarding
        isSkipped %logical index for possible skipping
        
    end
    
    %% methods
    methods
        
        %% ca_analysis
        % The function performs bleach correction, calculates the
        % amplitude and time variables from each intensity curve and adds 
        % them as properties to the ca_response object. The function is
        % called from the readCaData function in readData.m.
        function obj = ca_analysis(obj,ROI,cell)
            %% Bleach correction
            
            % Exctract raw data from the ca_response object.
            time = obj.timeVector;
            A = obj.rawData;
            ansId = 0;
            
            % Pick the interval used in searching for the minimum before the response.
            if ~isempty(obj.startId) == 1
                
                %In case the object already has fit data
                bounds = [obj.startFit, obj.startId];
                
            else
                
                %Adjust if needed
                bounds = [1, 400];
                
            end
            
            counter = 1;
            
            while ansId == 0
                
                B = A(bounds(1):bounds(2));
                
                if counter > 1 || ~isempty(obj.startId) == 1
                    
                    %In case the object already has a start index
                    obj.startId = bounds(2);
                              
                else
                    
                    %Finds the minimum value between fit start and end points
                    [~, obj.startId] = min(B);
                    
                    if obj.startId < 100
                        
                        %If the index is too close to start of the data,
                        %adds a certain amount of data points
                        obj.startId = obj.startId + 200;
                        
                    end
                    
                    obj.startId = round((obj.startId + (bounds(1)-1)));
                    
                end
                
                % Fit an exp model to the baseline and calculate corrected data.
                data2fit = A((bounds(1):obj.startId));
                fittedData = fit(time(bounds(1):obj.startId), data2fit, 'exp1');
                model = fittedData.a.*exp(fittedData.b.*time);
                baseline = mean(A(1:10)); % Start value for the corrected baseline.
                basevec = baseline*ones(length(time));
                difference = baseline - model;
                correctedA = A + difference;
                
                % Plot the original and corrected data
                figure('units','normalized','outerposition',[0 0 1 1]);
                subplot(1,2,1)
                hold on
                plot(time, A, 'b')
                plot(time(bounds(1):obj.startId), data2fit, 'r')
                plot(time, model, 'kREPLACE_WITH_DASH_DASH')
                plot(time, correctedA, 'g')
                plot(time, basevec, 'k-.')
                hold off
                
                title('Corrected data', 'Interpreter', 'none')
                legend('original data', 'data used in fitting', 'fitted model',...
                    'corrected data', 'baseline')
                xlabel('Time (s)')
                ylabel('Intensity')

                correctAnswer = 0;
                
                % Ask for user input and correction for the fit boundaries
                while correctAnswer == 0
                    prompt = 'Accept correction (y),skip correction (s),\nselect new boundaries (n) or discard response (d): ';
                    answer = input(prompt, 's');
                    
                    if strcmp(answer, 'y')
                        
                        obj.correctedData = correctedA;
                        obj.startFit = bounds(1);
                        bounds(2) = obj.startId; % The fit end point is taken 
                        % as the response start point (can be changed later by the user)
                        ansId = 1;
                        correctAnswer = 1;
                        
                    elseif strcmp(answer, 'n')
                        
                        % In case of 'n', give user the possibility to
                        % select new boundaries graphically with the mouse
                        disp('Select the boundaries for fitting with the mouse cursor.')
                        [bounds, ~] = ginput(2);
                        bounds = round(2*bounds); %Convert time data to index
                        counter = counter + 1;
                        correctAnswer = 1;
                        close
                        
                    elseif strcmp(answer, 's')
                        
                        % Possibility to skip bleach correction, e.g. if
                        % the baseline is too fluctuating for fitting.
                        obj.correctedData = obj.rawData;
                        bounds(2) = obj.startId;
                        data2fit = A(bounds(1):bounds(2));
                        obj.isSkipped = 1;
                        correctAnswer = 1;
                        ansId = 1;
                        
                    elseif strcmp(answer, 'd')
                        
                        % Possibility to discard the response if the data
                        % is not analyzable.
                        obj.correctedData = correctedA;
                        obj.isDiscarded = 1;
                        return
                        
                    else
                        
                        disp('Please enter y (yes), n (no), s (skip) or d (discard).');
                        
                    end
                    
                end
                
            end
            
            %% Calculate curve parameters
            
            % Calculate relative intensity and filter out noise
            obj.relativeData = obj.correctedData/mean(obj.correctedData(1:10));
            obj.filteredData = smooth(obj.relativeData, 'moving');
            
            % Find the points that are used in the calculations in case
            % the object parameters are empty.
            if isempty(obj.maxId) == 1
                
                [~, obj.maxId] = max(obj.filteredData); 
                halfway = (obj.filteredData(obj.maxId)+obj.filteredData(obj.startId))/2;
                % Find the points where the curve crosses the halfway value
                % (see findcrossings.m)
                crossings1 = findcrossings(obj.filteredData(obj.startId:obj.maxId),halfway);
                crossings2 = findcrossings(obj.filteredData(obj.maxId:end),halfway);
                % The first crossings are taken as the halfway points. Can
                % be changed e.g. to last crossings etc.
                obj.idx50_1 = crossings1(1) + obj.startId;
                obj.idx50_2 = crossings2(1) + obj.maxId;
                
                % Calculate the amplitude and time parameters
                obj.maxAmplitude = obj.filteredData(obj.maxId) - obj.filteredData(obj.startId) + 1;
                obj.time2max = time(obj.maxId) - time(obj.startId);
                obj.rise50 = time(obj.idx50_1) - time(obj.startId);
                obj.decay50 = time(obj.idx50_2) - time(obj.maxId);
                obj.duration50 = time(obj.idx50_2) - time(obj.idx50_1);
                
            end
           
            %% Plot the calculated parameters
            
            baseline2 = mean(obj.filteredData(1:10));
            basevec2 = baseline2*ones(length(time),1);
            halfway = (obj.filteredData(obj.maxId)+obj.filteredData(obj.startId))/2;
            halfvec = halfway*ones(length(time));
            
            subplot(1,2,2)
            hold on
            plot(time, obj.filteredData, 'HandleVisibility', 'off')
            plot(time, basevec2, 'HandleVisibility', 'off')
            plot(time, halfvec, 'HandleVisibility', 'off')
            plot(time(obj.startId), obj.filteredData(obj.startId), 'rx', 'LineWidth', 2)
            plot(time(obj.maxId), obj.filteredData(obj.maxId), 'kx', 'LineWidth', 2)
            plot(time(obj.idx50_1), obj.filteredData(obj.idx50_1), 'gx', 'LineWidth', 2)
            
            
            % In case the intensity doesn't fall back under 50%, the second halfway point 
            % is plotted in yellow (adjust the tolerance as needed) and decay50 and duration50
            % are marked as NaN, as they can't be calculated. This can happen also 
            % when the 50% points are too far apart in intensity, due to rapid changes in 
            % intensity and too small sampling interval.    
            if abs(obj.filteredData(obj.idx50_1) - obj.filteredData(obj.idx50_2)) > 0.03
                
                obj.decay50 = NaN;
                obj.duration50 = NaN;
                plot(time(obj.idx50_2), obj.filteredData(obj.idx50_2), 'yx', 'LineWidth', 2)
                
            else
                
                plot(time(obj.idx50_2), obj.filteredData(obj.idx50_2), 'cx', 'LineWidth', 2)
                
            end
            
            title('Analyzed data', 'Interpreter', 'none')
            legend('Response start point', 'Curve maximum', 'Halfway (rise)', 'Halfway (decay)')
            xlabel('time (s)')
            ylabel('Relative intensity')
            
            hold off
            
            suptitle([obj.cellLine, ' ', obj.surface, ' ', obj.timepoint,' ROI ', num2str(ROI), ' cell ', num2str(cell)])
            
            correctAnswer2 = 0;

            while correctAnswer2 == 0
                
                % Ask user input whether the calculated points are correct.
                prompt = 'Accept calculated points (y/n): ';
                answer = input(prompt, 's');
                
                if strcmp(answer, 'y')
                    
                    obj.correctedData = correctedA;
                    correctAnswer2 = 1;
                    
                elseif strcmp(answer, 'n')
                    
                    % In case corrections are needed. Points are selected
                    % in order (start, 50% rise, maximum, 50% decay) with
                    % mouse (left click -> new value, right click (or any 
                    % other input) -> keep old value)
                    disp('Select the points with the mouse cursor in the following order: start, halfway (rise), maximum, halfway(decay)')
                    [points, ~, button] = ginput(4);
                    
                    if button(1) == 1
                        obj.startId = round(2*points(1));
                    end
                    
                    if button(2) == 1
                        obj.idx50_1 = round(2*points(2));
                    end
                    
                    if button(3) == 1
                        obj.maxId = round(2*points(3));
                    end
                    
                    if button(4) == 1
                        obj.idx50_2 = round(2*points(4));
                    end
                    
                    % Calculate new points with the user input
                    obj.maxAmplitude = obj.filteredData(obj.maxId) - obj.filteredData(obj.startId) + 1;
                    obj.time2max = time(obj.maxId) - time(obj.startId);
                    obj.rise50 = time(obj.idx50_1) - time(obj.startId);
                    obj.decay50 = time(obj.idx50_2) - time(obj.maxId);
                    obj.duration50 = time(obj.idx50_2) - time(obj.idx50_1);
                    
                    halfway = (obj.filteredData(obj.maxId)+obj.filteredData(obj.startId))/2;
                    halfvec = halfway*ones(length(time));
                    
                    % Close the old figure and draw a new one
                    close
                    
                    figure('units','normalized','outerposition',[0 0 1 1]);
                    subplot(1,2,1)
                    hold on
                    plot(time, A, 'b')
                    plot(time(bounds(1):bounds(2)), data2fit, 'r')
                    plot(time, model, 'kREPLACE_WITH_DASH_DASH')
                    plot(time, correctedA, 'g')
                    plot(time, basevec, 'k-.')
                    
                    
                    title('Corrected data', 'Interpreter', 'none')
                    legend('original data', 'data used in fitting', 'fitted model', 'corrected data', 'baseline')
                    xlabel('Time (s)')
                    ylabel('Intensity')
                    hold off
                    
                    subplot(1,2,2)
                    hold on
                    plot(time, obj.filteredData, 'HandleVisibility', 'off')
                    plot(time, basevec2, 'HandleVisibility', 'off')
                    plot(time, halfvec, 'HandleVisibility', 'off')
                    plot(time(obj.startId), obj.filteredData(obj.startId), 'xr', 'LineWidth', 2)
                    plot(time(obj.maxId), obj.filteredData(obj.maxId), 'xk', 'LineWidth', 2)
                    plot(time(obj.idx50_1), obj.filteredData(obj.idx50_1), 'xg', 'LineWidth', 2)
                    
                    % In case the intensity doesn't fall back under 50%, the second halfway point 
                    % is plotted in yellow (adjust the tolerance as needed) and decay50 and duration50
                    % are marked as NaN, as they can't be calculated. This can happen also 
                    % when the 50% points are too far apart in intensity, due to rapid changes in 
                    % intensity and too small sampling interval.   
                    if abs(obj.filteredData(obj.idx50_1) - obj.filteredData(obj.idx50_2)) > 0.03
                        
                        obj.decay50 = NaN;
                        obj.duration50 = NaN;
                        plot(time(obj.idx50_2), obj.filteredData(obj.idx50_2), 'xy', 'LineWidth', 2)
                        
                    else
                        
                        plot(time(obj.idx50_2), obj.filteredData(obj.idx50_2), 'xc', 'LineWidth', 2)
                        
                    end
                    
                    title('Analyzed data', 'Interpreter', 'none')
                    legend('Response start point', 'Curve maximum', 'Halfway (rise)', 'Halfway (decay)')
                    xlabel('Time (s)')
                    ylabel('Relative intensity')
                    
                    hold off
                    
                    suptitle([obj.cellLine, ' ', obj.surface, ' ', obj.timepoint,' ROI ', num2str(ROI), ' cell ', num2str(cell)])
                    
                else
                    
                    disp('Please enter y or n.');
                    
                end
                
            end
            
            close
            
        end

    end
 
end
##### SOURCE END #####
--></body></html>